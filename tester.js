[{
    level: 1,
    year: 2023,
    challengeName: "solar-doomsday",
    question: 1,
    code: "\n\nimport unittest\nfrom unittest import mock\nimport json\n\n\nclass SolutionTestCase(unittest.TestCase):\n    def test_solution_positive_numbers(self):\n        expected = 15\n        with mock.patch('builtins.print'):\n            result = solution(5, 10)\n\n        self.assertEqual(result, expected)\n\n\n    def test_solution_negative_numbers(self):\n        expected = -15\n        with mock.patch('builtins.print'):\n            result = solution(-5, -10)\n        self.assertEqual(result, expected)\n\n    def test_solution_zero(self):\n        expected = 0\n        with mock.patch('builtins.print'):\n            result = solution(0, 0)\n        self.assertEqual(result, expected)\n\n        \nclass CustomTestResult(unittest.TestResult):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.test_results = {}\n        self.results = []\n        self.status = ''\n\n    def addSuccess(self, test):\n        self.test_results[test] = \"passed\"\n\n    def addFailure(self, test, err):\n        self.test_results[test] = \"failed\"\n    \n    def populateResult(self):\n        if not self.test_results:\n            self.results = \"Invalid solution.\"\n            self.status = 'error'\n            return\n        \n        if self.test_results and all(result == \"passed\" for result in self.test_results.values()):\n            self.status = 'passed'\n        else:\n            self.status = 'failed'\n        for index, (_, result) in enumerate(self.test_results.items()):\n            self.results.append({ \"test\": \"Test \" + str(index+1), \"result\" : result })\n\n            \n    def print_test_results(self):\n        self.populateResult()\n        output = {\"status\": self.status, \"results\": self.results}\n        json_output=json.dumps(output)\n        print(json_output)\n    \n\nif __name__ == '__main__':\n    suite = unittest.TestLoader().loadTestsFromTestCase(SolutionTestCase)\n    result = CustomTestResult()\n    suite.run(result)\n    result.print_test_results()\n"
  },
  {
    level: 2,
    year: 2023,
    challengeName: "ion-flux-relabeling",
    question: 1,
    code: "\n\nimport unittest\nfrom unittest import mock\nimport json\n\n\nclass SolutionTestCase(unittest.TestCase):\n    def test1(self):\n        expected = [0, 1, 2, 3, 4]\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"HELLO\")\n\n        self.assertEqual(result, expected)\n\n\n    def test2(self):\n        expected = [0, 2, 4]\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"HeLlO\")\n        self.assertEqual(result, expected)\n\n    def test3(self):\n        expected = []\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"hello\")\n        self.assertEqual(result, expected)\n        \n    def test4(self):\n        expected = []\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"\")\n        self.assertEqual(result, expected)\n\n        \nclass CustomTestResult(unittest.TestResult):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.test_results = {}\n        self.results = []\n        self.status = \'\'\n\n    def addSuccess(self, test):\n        self.test_results[test] = \"passed\"\n\n    def addFailure(self, test, err):\n        self.test_results[test] = \"failed\"\n    \n    def populateResult(self):\n        if not self.test_results:\n            self.results = \"Invalid solution.\"\n            self.status = \'error\'\n            return\n        \n        if self.test_results and all(result == \"passed\" for result in self.test_results.values()):\n            self.status = \'passed\'\n        else:\n            self.status = \'failed\'\n        for index, (_, result) in enumerate(self.test_results.items()):\n            self.results.append({ \"test\": \"Test \" + str(index+1), \"result\" : result })\n\n            \n    def print_test_results(self):\n        self.populateResult()\n        output = {\"status\": self.status, \"results\": self.results}\n        json_output=json.dumps(output)\n        print(json_output)\n    \n\nif __name__ == \'__main__\':\n    suite = unittest.TestLoader().loadTestsFromTestCase(SolutionTestCase)\n    result = CustomTestResult()\n    suite.run(result)\n    result.print_test_results()\n"
  },
  {
    level: 2,
    year: 2023,
    challengeName: "lovely-lucky-lambs",
    question: 2,
    code: "\n\nimport unittest\nfrom unittest import mock\nimport json\n\n\nclass SolutionTestCase(unittest.TestCase):\n    def test1(self):\n        expected = \"b\"\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"abc\")\n\n        self.assertEqual(result, expected)\n\n\n    def test2(self):\n        expected = \"\"\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"aaaa\")\n        self.assertEqual(result, expected)\n\n    def test3(self):\n        expected = \"\"\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"\")\n        self.assertEqual(result, expected)\n        \n    def test4(self):\n        expected = \"X\"\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"X\")\n        self.assertEqual(result, expected)\n\n    def test5(self):\n        expected = \"L\"\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"HELLO\")\n        self.assertEqual(result, expected)\n        \nclass CustomTestResult(unittest.TestResult):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.test_results = {}\n        self.results = []\n        self.status = \'\'\n\n    def addSuccess(self, test):\n        self.test_results[test] = \"passed\"\n\n    def addFailure(self, test, err):\n        self.test_results[test] = \"failed\"\n    \n    def populateResult(self):\n        if not self.test_results:\n            self.results = \"Invalid solution.\"\n            self.status = \'error\'\n            return\n        \n        if self.test_results and all(result == \"passed\" for result in self.test_results.values()):\n            self.status = \'passed\'\n        else:\n            self.status = \'failed\'\n        for index, (_, result) in enumerate(self.test_results.items()):\n            self.results.append({ \"test\": \"Test \" + str(index+1), \"result\" : result })\n\n            \n    def print_test_results(self):\n        self.populateResult()\n        output = {\"status\": self.status, \"results\": self.results}\n        json_output=json.dumps(output)\n        print(json_output)\n    \n\nif __name__ == \'__main__\':\n    suite = unittest.TestLoader().loadTestsFromTestCase(SolutionTestCase)\n    result = CustomTestResult()\n    suite.run(result)\n    result.print_test_results()\n"
  },
  {
    level: 3,
    year: 2023,
    challengeName: "bomb-baby",
    question: 1,
    code: "\n\nimport unittest\nfrom unittest import mock\nimport json\n\n\nclass SolutionTestCase(unittest.TestCase):\n    def test1(self):\n        expected = True\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"typhoon\", \"opython\")\n\n        self.assertEqual(result, expected)\n\n\n    def test2(self):\n        expected = False\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"bob\", \"alice\")\n        self.assertEqual(result, expected)\n\n    def test3(self):\n        expected = True\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"listen\", \"silent\")\n        self.assertEqual(result, expected)\n        \n    def test4(self):\n        expected = False\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"abcd\", \"abcde\")\n        self.assertEqual(result, expected)\n\n    def test5(self):\n        expected = True\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"astronomer\", \"moon starer\")\n        self.assertEqual(result, expected)\n    \n    def test6(self):\n        expected = True\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"\", \"\")\n        self.assertEqual(result, expected)\n        \n        \nclass CustomTestResult(unittest.TestResult):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.test_results = {}\n        self.results = []\n        self.status = \'\'\n\n    def addSuccess(self, test):\n        self.test_results[test] = \"passed\"\n\n    def addFailure(self, test, err):\n        self.test_results[test] = \"failed\"\n    \n    def populateResult(self):\n        if not self.test_results:\n            self.results = \"Invalid solution.\"\n            self.status = \'error\'\n            return\n        \n        if self.test_results and all(result == \"passed\" for result in self.test_results.values()):\n            self.status = \'passed\'\n        else:\n            self.status = \'failed\'\n        for index, (_, result) in enumerate(self.test_results.items()):\n            self.results.append({ \"test\": \"Test \" + str(index+1), \"result\" : result })\n\n            \n    def print_test_results(self):\n        self.populateResult()\n        output = {\"status\": self.status, \"results\": self.results}\n        json_output=json.dumps(output)\n        print(json_output)\n    \n\nif __name__ == \'__main__\':\n    suite = unittest.TestLoader().loadTestsFromTestCase(SolutionTestCase)\n    result = CustomTestResult()\n    suite.run(result)\n    result.print_test_results()\n"
  },
  {
    level: 4,
    year: 2023,
    challengeName: "doomsday-fuel",
    question: 1,
    code: "\n\nimport unittest\nfrom unittest import mock\nimport json\n\n\nclass SolutionTestCase(unittest.TestCase):\n    \n    def test1(self):\n        expected = True\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"bob\")\n\n        self.assertEqual(result, expected)\n\n    def test2(self):\n        expected = False\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"abcd\")\n        self.assertEqual(result, expected)\n\n    def test3(self):\n        expected = True\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"A man a plan a canal Panama\")\n        self.assertEqual(result, expected)\n        \n    def test4(self):\n        expected = False\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"A man on the moon\")\n        self.assertEqual(result, expected)\n    \n    def test5(self):\n        expected = True\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"\")\n        self.assertEqual(result, expected)\n\n    def test6(self):\n        expected = True\n        with mock.patch(\'builtins.print\'):\n            result = solution(\" \")\n        self.assertEqual(result, expected)\n\n    def test7(self):\n        expected = True\n        with mock.patch(\'builtins.print\'):\n            result = solution(\" x\")\n        self.assertEqual(result, expected)\n        \nclass CustomTestResult(unittest.TestResult):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.test_results = {}\n        self.results = []\n        self.status = \'\'\n\n    def addSuccess(self, test):\n        self.test_results[test] = \"passed\"\n\n    def addFailure(self, test, err):\n        self.test_results[test] = \"failed\"\n    \n    def populateResult(self):\n        if not self.test_results:\n            self.results = \"Invalid solution.\"\n            self.status = \'error\'\n            return\n        \n        if self.test_results and all(result == \"passed\" for result in self.test_results.values()):\n            self.status = \'passed\'\n        else:\n            self.status = \'failed\'\n        for index, (_, result) in enumerate(self.test_results.items()):\n            self.results.append({ \"test\": \"Test \" + str(index+1), \"result\" : result })\n\n            \n    def print_test_results(self):\n        self.populateResult()\n        output = {\"status\": self.status, \"results\": self.results}\n        json_output=json.dumps(output)\n        print(json_output)\n    \n\nif __name__ == \'__main__\':\n    suite = unittest.TestLoader().loadTestsFromTestCase(SolutionTestCase)\n    result = CustomTestResult()\n    suite.run(result)\n    result.print_test_results()\n"
  },
  {
    level: 5,
    year: 2023,
    challengeName: "fuel-injection-perfection",
    question: 1,
    code: "\nimport unittest\nfrom unittest import mock\nimport json\n\n\nclass SolutionTestCase(unittest.TestCase):\n    def test1(self):\n        expected = 3\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"1001101000110\")\n        self.assertEqual(result, expected)\n\n    def test2(self):\n        expected = 0\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"11111\")\n        self.assertEqual(result, expected)\n\n    def test3(self):\n        expected = 8\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"0000011100000000\")\n        self.assertEqual(result, expected)\n\n    def test4(self):\n        expected = 1\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"010101\")\n        self.assertEqual(result, expected)\n\n    def test5(self):\n        expected = 1\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"101010101\")\n        self.assertEqual(result, expected)\n        \n    def test6(self):\n        expected = 8\n        with mock.patch(\'builtins.print\'):\n            result = solution(\"0000000011100000000\")\n        self.assertEqual(result, expected)\n        \nclass CustomTestResult(unittest.TestResult):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.test_results = {}\n        self.results = []\n        self.status = \'\'\n\n    def addSuccess(self, test):\n        self.test_results[test] = \"passed\"\n\n    def addFailure(self, test, err):\n        self.test_results[test] = \"failed\"\n    \n    def populateResult(self):\n        if not self.test_results:\n            self.results = \"Invalid solution.\"\n            self.status = \'error\'\n            return\n        \n        if self.test_results and all(result == \"passed\" for result in self.test_results.values()):\n            self.status = \'passed\'\n        else:\n            self.status = \'failed\'\n        for index, (_, result) in enumerate(self.test_results.items()):\n            self.results.append({ \"test\": \"Test \" + str(index+1), \"result\" : result })\n\n            \n    def print_test_results(self):\n        self.populateResult()\n        output = {\"status\": self.status, \"results\": self.results}\n        json_output=json.dumps(output)\n        print(json_output)\n    \n\nif __name__ == \'__main__\':\n    suite = unittest.TestLoader().loadTestsFromTestCase(SolutionTestCase)\n    result = CustomTestResult()\n    suite.run(result)\n    result.print_test_results()\n"
  },
  
]